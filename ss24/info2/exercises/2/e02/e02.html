<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Di 30. Apr 12:47:50 CEST 2024 Markdown/AsciiMath to HTML (by marked)</title>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=AM_CHTML"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  asciimath2jax: {
    delimiters: [['$','$']]
  }
});
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body class="markdown-body">
  <div id="display"></div>
  <script>
    content =
"# Gruppe\n\n- Linus Keiser\n- Simon Keiser\n\n# 1\n\n## 1a\n\n| Prozesse     | $P_1$ | $P_2$ | $P_3$ | $P_4$ | $P_5$ | $P_6$ |\n| ------------ | :---: | :---: | :---: | :---: | :---: | :---: |\n| Ankunftszeit |   0   | 4000  | 5000  | 39000 | 42000 | 43000 |\n| Rechenzeit   | 15000 | 20000 | 5000  | 50000 | 25000 | 10000 |\n\n#### Variablen:\n\n`t` ist die Zeit, $P$ der momentan ausgewählte Prozess, $W$ die Menge der bereiten Prozesse, und ggf. deren verbleibender Rechenzeit, und $P_\"complete\"$ die Menge der abgeschlossenen Prozesse.\n\n### Nicht-unterbrechendes Scheduling mit SJF-Verfahren\n\n|      t | $P$   | $W$          | $P_\"complete\"$                   |\n| -----: | :---- | :----------- | :------------------------------- |\n|      0 | $P_1$ | ${P_2, P_3}$ | $O/$                             |\n|  15000 | $P_3$ | ${P_2}$      | ${P_1}$                          |\n|  20000 | $P_2$ | ${P_4}$      | ${P_1, P_3}$                     |\n|  40000 | $P_4$ | $O/$         | ${P_1, P_2, P_3}$                |\n|  90000 | $P_6$ | ${P_5}$      | ${P_1, P_2, P_3, P_4}$           |\n| 100000 | $P_5$ | $O/$         | ${P_1, P_2, P_3, P_4, P_6}$      |\n| 125000 |       | $O/$         | ${P_1, P_2, P_3, P_4, P_5, P_6}$ |\n\n#### Resultat:\n\n| id    | $t_\"arrival\"$ | $t_\"start\"$ | $t_\"end\"$ |   $w$ |\n| :---- | ------------: | ----------: | --------: | ----: |\n| $P_1$ |             0 |           0 |     15000 |     0 |\n| $P_2$ |          4000 |       20000 |     40000 | 16000 |\n| $P_3$ |          5000 |       15000 |     20000 | 10000 |\n| $P_4$ |         39000 |       40000 |     90000 |  1000 |\n| $P_5$ |         42000 |      100000 |    115000 | 58000 |\n| $P_6$ |         43000 |       90000 |    100000 | 47000 |\n\n**$\\bar{w} = (0 + 16000 + 10000 + 1000 + 58000 + 47000) / 6  = 22000$**\n\n---\n\n### Unterbrechendes Scheduling mit Round-Robin-Verfahren\n\nDie Länge eines Zeitschlitzes beträgt in diesem Beispiel arbiträr 5000 Zeiteinheiten.\n\n![Gantt-Diagramm](./build/rr_gantt.png)\n\n<!-- ![Gantt-Diagramm](https://kvnu.github.io/sem2/info2/e02/build/rr_gantt.png) -->\n\n|      t | $P$   | $W$                            | $P_\"complete\"$                   |\n| -----: | :---- | :----------------------------- | :------------------------------- |\n|      0 | $P_1$ | $O/$                           | $O/$                             |\n|   5000 | $P_2$ | ${(P_1, 10000)}$               | $O/$                             |\n|  10000 | $P_1$ | ${(P_3, 5000), (P_2, 15000)}$  | $O/$                             |\n|  15000 | $P_3$ | ${(P_2, 15000), (P_1, 5000)}$  | $O/$                             |\n|  20000 | $P_2$ | ${(P_1, 5000)}$                | ${P_3}$                          |\n|  25000 | $P_1$ | ${(P_2, 10000)}$               | ${P_3}$                          |\n|  30000 | $P_2$ | $O/$                           | ${P_3, P_1}$                     |\n|  35000 | $P_2$ | $O/$                           | ${P_3, P_1}$                     |\n|  40000 | $P_4$ | $O/$                           | ${P_3, P_1, P_2}$                |\n|  45000 | $P_5$ | ${(P_6, 10000), (P_4, 45000)}$ | ${P_3, P_1, P_2}$                |\n|  50000 | $P_6$ | ${(P_4, 45000), (P_5, 20000)}$ | ${P_3, P_1, P_2}$                |\n|  55000 | $P_4$ | ${(P_5, 20000), (P_6, 5000)}$  | ${P_3, P_1, P_2}$                |\n|  60000 | $P_5$ | ${(P_6, 5000), (P_4, 40000)}$  | ${P_3, P_1, P_2}$                |\n|  65000 | $P_6$ | ${(P_4, 40000), (P_5, 15000)}$ | ${P_3, P_1, P_2}$                |\n|  70000 | $P_4$ | ${(P_5, 15000)}$               | ${P_3, P_1, P_2, P_6}$           |\n|  75000 | $P_5$ | ${(P_4, 35000)}$               | ${P_3, P_1, P_2, P_6}$           |\n|  80000 | $P_4$ | ${(P_5, 10000)}$               | ${P_3, P_1, P_2, P_6}$           |\n|  85000 | $P_5$ | ${(P_4, 30000)}$               | ${P_3, P_1, P_2, P_6}$           |\n|  90000 | $P_4$ | ${(P_5, 5000)}$                | ${P_3, P_1, P_2, P_6}$           |\n|  95000 | $P_5$ | ${(P_4, 25000)}$               | ${P_3, P_1, P_2, P_6}$           |\n| 100000 | $P_4$ | $O/$                           | ${P_3, P_1, P_2, P_6, P_5}$      |\n| 125000 |       | $O/$                           | ${P_3, P_1, P_2, P_6, P_5, P_4}$ |\n\n#### Resultat:\n\n**$A$** ist die Menge der Zeitspannen, in denen ein Prozess aktiv war.\n\n| id    | $t_\"arrival\"$ | $t_\"end\"$ |   $w$ | $A$                                                                                                  |\n| :---- | ------------: | --------: | ----: | :--------------------------------------------------------------------------------------------------- |\n| $P_3$ |          5000 |     20000 | 10000 | ${(15000, 20000)}$                                                                                   |\n| $P_1$ |             0 |     30000 | 15000 | ${(0, 5000), (10000, 15000), (25000, 30000)}$                                                        |\n| $P_2$ |          4000 |     40000 | 16000 | ${(5000, 10000), (20000, 25000), (30000, 35000), (35000, 40000)}$                                    |\n| $P_6$ |         43000 |     70000 | 17000 | ${(50000, 55000), (65000, 70000)}$                                                                   |\n| $P_5$ |         42000 |    100000 | 33000 | ${(45000, 50000), (60000, 65000), (75000, 80000), (85000, 90000), (95000, 100000)}$                  |\n| $P_4$ |         39000 |    125000 | 36000 | ${(40000, 45000), (55000, 60000), (70000, 75000), (80000, 85000), (90000, 95000), (100000, 125000)}$ |\n\n**$\\bar{w} = (15000 + 16000 + 10000 + 36000 + 33000 + 17000) / 6= 21166.666$**\n\n---\n\n## 1b\n\nDas allgemeine Kriterium für die Auswahl des nächsten zu aktivierenden Prozesses, sowohl im nicht-unterbrechenden als auch im unterbrechenden Scheduling, ist die **kürzeste verbleibende Rechenzeit**. Dieses Kriterium lässt sich z.B. durch das Schedulingverfahren SJF für nicht-unterbrechendes Scheduling und SRT für unterbrechendes Scheduling erfüllen.\n\n1. Nicht-unterbrechendes Scheduling: SJF\n   - Wenn ein Prozess beendet wird und ein neuer zu aktivierenden Prozess ausgewählt wird, wählt der Scheduler den Prozess mit der kürzesten Gesamtausführungszeit aus der Menge der bereiten Prozesse\n   - Wenn es mehrere Prozesse mit der gleichen Rechenzeit gibt, kann der Scheduler den Prozess auswählen, der zuerst eingetroffen ist (First Come First Serve - FCFS), oder andere Mechanismen zur Aufhebung von Gleichständen verwenden.\n   - Indem der Scheduler den Prozess mit der kürzesten verbleibenden Rechenzeit als nächstes auswählt, wird sichergestellt, dass kürzere Prozesse schnell beendet werden, wodurch sich die Wartezeit für alle Prozesse in der Warteschlange verkürzt.\n2. Unterbrechendes Scheduling: SRT\n   - In diesem Fall sollte der Scheduler die verbleibende Rechenzeit der Prozesse berücksichtigen, nicht nur ihre Gesamtausführungszeit. Wenn ein neuer Prozess eintrifft oder der aktuelle Prozess unterbrochen wird, wählt der Scheduler den Prozess mit der kürzesten verbleibenden Rechenzeit aus der Menge der bereiten Prozesse aus.\n   - Wenn es mehrere Prozesse mit der gleichen verbleibenden Rechenzeit gibt, kann der Scheduler dieselben Mechanismen zur Aufhebung des Gleichstands wie oben erwähnt verwenden.\n   - Indem der Scheduler den Prozess mit der kürzesten verbleibenden Zeit zuerst auswählt, wird sichergestellt, dass Prozesse mit weniger verbleibender Zeit schnell beendet werden, wodurch die durchschnittliche Wartezeit für alle Prozesse in der Warteschlange verringert wird.\n\nDurch die konsequente Auswahl des Prozesses mit der kürzesten verbleibenden Rechenzeit ermöglicht der Scheduler, dass kürzere Prozesse schneller abgeschlossen werden können, wodurch sich die Gesamtwartezeit für alle Prozesse in der Warteschlange verringert. Die Auswahl nach diesem Kriterium trägt dazu bei, die durchschnittliche Wartezeit für das System zu minimieren und gleichzeitig die konkurrierenden Anforderungen der verschiedenen Prozesse auszugleichen.\n\n# 2\n\n## 2a\n\nDurch das mehrfache Aufführen eines Prozesses in der Liste wird er gewissermaßen bevorzugt. Sollte der Prozess nach Ablauf der Zeitscheibe noch nicht abgeschlossen sein, wird er am Ende der Prozessliste eingeordnet. Da er jedoch durch die mehrfache Auflistung bereits an einer früheren Stelle in der Liste steht wird er erneut Rechenzeit bekommen bevor es das round-robin-Verfahren eigentlich vorsähe. Dadurch können sich die Rechenzeiten verschiedener Prozesse in einem gegebenen Zeitintervall trotz ähnlicher Ankunfts- und Gesamtrechenzeit sehr stark unterscheiden: Ein Prozess der zu beginn dreimal in der Liste steht wird auf lange Sicht auch dreimal soviel Rechenzeit bekommen wie nur einmal aufgeführter Prozess. Das mehrfache Auflisten erhöht also die Frequenz in der ein Prozess Rechenzeit zugeteilt bekommt und bricht somit die Fairness des round-robin-Verfahrens. Dieser Effekt wird durch im Verhältnis zu den Zeitscheiben lange Rechenzeiten verstärkt.\n\n## 2b\n\nGenau aus den zuvor beschriebenen Gründen kann eine Mehrfachauflistung “besonders wichtiger” Prozesse oder solcher mit einer sehr hohen Rechenzeit sinnvoll sein, um eine Priorisierung bei der Zuteilung der Prozessorzeit zu erwirken.\n\n## 2c\n\nWird ein Prozess beim round-robin-Verfahren blockiert wird sofort der nächste Prozess ausgewählt - d.h. ein Prozesswechsel durchgeführt. Durch eine mehrfache Listung eines blockierten Prozesses werden somit mehrere “überflüssige” Prozesswechsel durchgeführt. Dies wirkt sich negativ auf die Performance aus, da es zu hohen Prozesswechselkosten führt.\n";async function displayer(){ // MathJax is not usable right after import, so we just wait and check until it is
    // markdown and asciimath do not naturally cooperate - we have to extract the asciimath parts and insert them later
	// we have to differentiate though: if the asciimath parts were in code areas (i.e. pre-tags), then we do not want to convert them
	//
	// we note that asciimath and pre-tags can not be interleaved in any sensible way, so we ignore that case
	var mathCounter = 0;
	var mathContents = [];
	while(((content.match(/\$/g) || []).length >= 2)){ // while there is still possible AsciiMath
		var start = content.indexOf("$");
		var end = content.indexOf("$", start + 1);
		mathContents.push(content.substring(start, end + 1));
		content = content.substring(0, start) + "<span id = 'ASCIIMATHREINSERTIONPLACEHOLDER" + mathCounter + "'></span>" + content.substring(end + 1); // it would be nicer to do without this, but what about sorting out hBsigns inside backtick-maths, or the other way around?
		mathCounter++;
	}

	while(typeof(MathJax) == "undefined"){ // we need MathJax in the next step, and may have to wait until it is initialized (does not happen on immediately import (even though it is not async))
		await new Promise(resolve => setTimeout(resolve, 100));
	}
	document.getElementById("display").innerHTML = marked.parse(content);
	for(var mathNumber = 0; mathNumber < mathCounter; mathNumber++){ // here we go through all parent elements of any contained tag and check if they are <pre>-elements if one is, then this is code ()
		var edEl = document.getElementById('ASCIIMATHREINSERTIONPLACEHOLDER' + mathNumber);
		if(edEl == null){ // the tag has fallen into a code area, turning it into plain text
		    document.body.outerHTML = document.body.outerHTML.replace("&lt;span id = 'ASCIIMATHREINSERTIONPLACEHOLDER" + mathNumber + "'&gt;&lt;/span&gt;", mathContents[mathNumber])
		}
		else{
			edEl.innerHTML = mathContents[mathNumber];
			MathJax.Hub.Typeset(edEl);
		}
	}
  };

  displayer();
  </script>
</body>
</html>

</body>
</html>
